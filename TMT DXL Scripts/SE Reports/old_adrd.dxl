// SE Report: Report Old AD/RD Citations
/* 
 Generate Systems Engineering Report: Report Old AD/RD Citations - for TMT
 
 Version:	SE Report Old AD-RDs v4.dxl

 Description: 	The purpose of this script is to report on the state of AD/RD links in the DRD modules.
		The script outputs a text report.
		 
 Process:	The script performs these steps:
		1) Examines each of the modules listed in the script code
		2) Looks for any outlinks in section 1 to the Documents Register
		3) For each linked document, the script looks for any newer rev of the same document
			- newer docs are reported so that links might be updated by the module custodian
		4) The script does not change anything
			- some links are supposed to point to older versions
			- any changes are then done by the module custodians 

 Assumptions:	1) the output file is named "SR_report.txt"
		2) the script only examines the modules named in the string array moduleNames[]
			- to change the modules examined, simply edit the code
		3) the Documents Register module name is hard-coded:
			"/TMT Requirements/Documents Register/Documents Register"
		4) the Documents link module name is hard-coded:
			"/TMT Requirements/Links/Documents"
		5) the script requires read access to all listed DRD modules and the Documents module

 If the Script Crashes:
		If the script crashes or your DOORS DB connection drops, then be advised that some
		modules might remain open.  The script opens each DRD module, one ad a time, read-only
		and does NOT display them.  Likewise, it opens the Documents Register module and
		keeps it hidden.  If the script crashes then there will likely be 2 modules left open
		(one DRD module and the Documents module).  You will not notice this because they are
		hidden.  You can easily se all hidden open modules using the DOORS menu item:
		Tools / Manage Open Modules...
		By opening the modules read-only, then if the user is kicked out and they do not promptly
		reconnect to DOORS, then the lingering open modules won't prevent other users from
		getting work done.


 Directions:	1) open the module you want to edit
		2) in that module window, select menu item: Tools / Edit DXL...
		3) paste this script code into the dialog window and click "Run"


*/
pragma runLim, 0	// suppress DXL execution timeout


string filename = "SR_report.txt"		// define output filename


//=======================================================================================================
// Variable declarations

string moduleNames[] = {	//-
	"/TMT Requirements/Level 0 Requirements/OPSPlan", //-
	"/TMT Requirements/Level 0 Requirements/SRD", //-
	"/TMT Requirements/Level 1 Requirements/OAD", //-
	"/TMT Requirements/Level 1 Requirements/OPSRD", //-
	"/TMT Requirements/Level 1 Requirements/ORD", //-
	"/TMT Requirements/Level 2 Requirements/Facilities/ENC DRD", //-
	"/TMT Requirements/Level 2 Requirements/Facilities/SUM DRD", //-
	"/TMT Requirements/Level 2 Requirements/Instrumentation/CRYO DRD", //-
	"/TMT Requirements/Level 2 Requirements/Instrumentation/IRIS DRD", //-
	"/TMT Requirements/Level 2 Requirements/Instrumentation/NFIRAOS DRD", //-
	"/TMT Requirements/Level 2 Requirements/Operations/CSW", //-
	"/TMT Requirements/Level 2 Requirements/Operations/SCMS", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/APS DRD", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/M1CS DRD", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/M1S DRD", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/M2S DRD", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/M3S DRD", //-
	"/TMT Requirements/Level 2 Requirements/Telescope/STR DRD", //-
	"/TMT Requirements/Level 3 Requirements/M1CS/M1CS Actuator DRD", //-
	"/TMT Requirements/Level 3 Requirements/M1CS/M1CS Sensor DRD", //-
	"/TMT Requirements/Level 3 Requirements/NFIRAOS/NRTC DRD", //-
	"/TMT Requirements/Level 3 Requirements/NFIRAOS/VCAM DRD", //-
	"/TMT Requirements/Level 3 Requirements/NFIRAOS/NWC DRD"}

int numModules = sizeof moduleNames

string Documents_Module 	= "/TMT Requirements/Documents Register/Documents Register"
Module docModule
string LinkModuleName 		= "/TMT Requirements/Links/Documents"
Link outLink

int i
string 		thisModuleName
ModName_ 	thisModuleRef
Item 		thisModuleItem
Module 		thisModule

Object o
Object d
string obj_number
int countADRD

string dccDocHandleHyperlink = ""
string dccDocVersionHyperlink = ""
string dccDocNo = ""
string dccDocTitle = ""
string dccDocRev = ""
string dccDocStatus = ""
string DocumentTitle = ""
string DocumentNo = ""
string DocumentRev = ""
string CADDocumentNo = ""
string DocumentHyperlink = ""
int link_absno
string link_objtxt
string link_supersede
string titleinfo
int doc_absno
int newer_absno
int obj_absno
string doc_no
string doc_docno
string doc_status
string doc_objtxt
bool sameDoc
int loopcounter




// Open the current project

Project p = current Project
if (null p) {
   ack "No project is open.  Aborting."
   halt
}
print "Project " (name p) "\n"

print "Current Dir:" currentDirectory "\n"



//=======================================================================================================
// Open the Documents module (read-only)

print "Opening the Documents module...  \n"

docModule = read(Documents_Module, false)
if (null docModule)
{
   ack "The Documents module did NOT open!  Aborting."
   halt
}


//=======================================================================================================
// Check if we can open the output file

output = write filename
if (null output) {
   ack "Failed to open output file.  Aborting."
   halt
}
print "Output file: " filename "\n"

loopcounter = 0


// Begin report

output << "TMT SE Report: Link Status for AD/RD Sections in Each DRD \n"
string thedate = stringOf(today)
output << thedate "\n\n"
// output << stringOf(dateOf intOf today) "\n"		// this adds the time of day, but changes date to xx/xx/xx format
output << "The IDs reported below are the DOORS IDs for the objects listed. \n\n\n"



//=======================================================================================================
// Loop over the list of modules


for (i=0; i < numModules; i++)
{
   thisModuleName = moduleNames[i]
   print "Processing: " thisModuleName "\n"
   output << "\nPROCESSING: " thisModuleName "\n"

   if (!module(thisModuleName)) {		// error trapping, report and skip
      print "   ERROR: this is not a module or it is not readable.  Skipping. \n"
      continue					// jump to the next in this loop
   }

   thisModuleRef = module(thisModuleName)	// get the module handle from the module name
   if (null thisModuleRef) {			// error trapping, report and skip
      print "   ERROR: got a null module handle.  Skipping. \n"
      continue
   }


loopcounter++
//if (loopcounter > 2) {break}		// debug line to limit run to a few modules during testing

// Open this module

   thisModule = read(thisModuleName,false)	// open the module for read
   if (null thisModule) {
      ack "   ERROR: unable to open this module.  Skipping. \n"
      output << "   ERROR: unable to open this module.  Skipping. \n"
      continue
   }


//=======================================================================================================
// Process this module - loop over objects in section 1, examining links to the Documents module

   countADRD = 0
   for o in thisModule do {			// loop over the objects in this module

      obj_number = number(o)			// is a string, e.g. 1.4-2-5 
      if ( obj_number >= "2" ) {break}		// jump out of loop over objects if past section 1
      obj_absno = o."Absolute Number"


      for outLink in o->LinkModuleName do	// loop over all outlinks to the Docs module
      {
         countADRD++				// count the number of links

         dccDocNo 		= (target outLink)."dccDocNo"
//         dccDocRev 		= (target outLink)."dccDocRev"
//         dccDocTitle 		= (target outLink)."dccDocTitle"
         dccDocStatus 		= (target outLink)."dccDocStatus"
//         DocumentTitle 		= (target outLink)."DocumentTitle"
         DocumentNo 		= (target outLink)."DocumentNo"
//         CADDocumentNo 		= (target outLink)."CADDocumentNo"
//         DocumentRev 		= (target outLink)."DocumentRev"
//         DocumentHyperlink 	= (target outLink)."DocumentHyperlink"
//         dccDocHandleHyperlink 	= (target outLink)."dccDocHandleHyperlink"
//         dccDocVersionHyperlink = (target outLink)."dccDocVersionHyperlink"
         link_absno           	= (target outLink)."Absolute Number"
         link_objtxt            = (target outLink)."Object Text"
         link_supersede 	= (target outLink)."SupersedingDocument"

         print "   Link from " obj_absno " to " link_absno " is being examined.  \n"


// If the cited document is not the "LATEST", then look for one labeled as latest.

         if (dccDocStatus != "LATEST") {


            for d in docModule do {			// loop over all docs in the Docs module

               doc_absno = d."Absolute Number"

               if (doc_absno == link_absno) {continue}		// skip this if it's the linked doc

               doc_no     = d."dccDocNo"
               doc_status = d."dccDocStatus"
               doc_docno  = d."DocumentNo"
               doc_objtxt = d."Object Text"
               titleinfo = ""
//               if (length(doc_objtxt) < 60) {
                  titleinfo = doc_objtxt
//               } else {
//                  titleinfo = doc_objtxt[0:60] "..."
//               }


// Check if this doc is the same as the linked doc.  
//	Note: "same" = both docs using the same dccDocNo or DocumentNo, 
//                     or object text (if both dccDocNo and DocumentNo are blank)

               sameDoc = false
               if (dccDocNo == "") {					// dccDocNo empty, so check DocumentNo

                  if (DocumentNo == "") {	// dccDocNo blank + DocumentNo blank = can't use these to find matching docs
						// will use the object text, which should be populated with either doc title or other

                     if (doc_objtxt == link_objtxt) { sameDoc = true }


                  } else {			// dccDocNo blank + DocumentNo's match and are not blank

                     if (DocumentNo == doc_docno) { sameDoc = true }

                  }

               } else {							// dccDocNo not empty

                  if (dccDocNo == doc_no) { sameDoc = true }

               }

               if (sameDoc) {					// this doc is the same, but different version
                  if (doc_status == "LATEST") {			// is this doc marked as latest
								//   this is therefore newer than the linked doc

                     newer_absno = doc_absno
                     print "   Link from DRD ID " obj_absno " to Doc ID " link_absno " is old.  Newer is: " doc_absno "  \n"
                     output << "      Link from DRD ID " obj_absno " to Document ID " link_absno " is old. \n"
                     output << "           Newer Doc is: " doc_absno "\n"
                     output << "           Title:        " titleinfo " \n"
                     if (link_supersede != "") {
                        output << "           Original Linked Doc Marked as Superseded by: " link_supersede " \n"
                     }
                    


                     doc_status = ""		// clear status to ensure good comparison on next pass in loop

                  }
               }


            }	// end of loop over all docs in Docs module


         }


      }		// end of loop over outlinks to the Docs module



   }	// end of loop over objects in this module

   print "   AD/RD links found in this module: " countADRD "\n"
   output << "      AD/RD links found in this module: " countADRD "\n"

// Close this module

   close(thisModule, false)


}	// end of loop over list of modules



output << "\n\nEND OF REPORT. \n"




//=======================================================================================================
// Clear memory (becuase DXL is not good at memory management)



close(docModule)			// close the Documents module



//=======================================================================================================
// Print final output summary


print "Finished \n"
